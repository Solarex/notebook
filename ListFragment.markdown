ListFragment
============
+ ``ListFragment`` has a default layout that consists of a single list view. However, if you desire, you can customize the fragment layout by returning your own view hierarchy from ``onCreateView(LayoutInflater, ViewGroup, Bundle)``. To do this, your view hierarchy must contain a ``ListView`` object with the id ``"@android:id/list"`` (or ``list`` if it's in code).
+ You can specify the layout of individual rows in the list. You do this by specifying a layout resource in the ``ListAdapter`` object hosted by the fragment (the ``ListAdapter`` binds the ``ListView`` to the data; more on this later).在ListAdapter绑定数据到ListView时可以指定每一行的layout.
+ You bind the ListFragment's ListView object to data using a class that implements the ``ListAdapter`` interface. Android provides two standard list adapters: ``SimpleAdapter`` for static data (Maps), and ``SimpleCursorAdapter`` for ``Cursor`` query results.You must use ``ListFragment.setListAdapter()`` to associate the list with an adapter. **Do not directly call ``ListView.setAdapter()`` or else important initialization will be skipped.**

DialogFragment
==============
+ ``DialogFragment`` does various things to keep the fragment's lifecycle driving it, instead of the Dialog. Note that dialogs are generally autonomous entities -- they are their own window, receiving their own input events, and often deciding on their own when to disappear (by receiving a back key event or the user clicking on a button).``DialogFragment`` needs to ensure that what is happening with the Fragment and Dialog states remains consistent. To do this, it watches for dismiss events from the dialog and takes care of removing its own state when they happen. This means you should use ``show(FragmentManager, String)`` or ``show(FragmentTransaction, String)`` to add an instance of ``DialogFragment`` to your UI, as these keep track of how ``DialogFragment`` should remove itself when the dialog is dismissed.``DialogFragment``中``Dialog``是自主的，可以有自己的window，接收自己的时间并作出处理。``DialogFragment``需要保证fragment和Dialog的状态一致。

Handler
=========
+ A ``Handler`` allows you to send and process ``Message`` and ``Runnable`` objects associated with a thread's ``MessageQueue``. Each ``Handler`` instance is associated with a single thread and that thread's message queue. When you create a new ``Handler``, it is bound to the ``thread / message queue`` of the thread that is creating it -- from that point on, it will deliver messages and runnables to that message queue and execute them as they come out of the message queue.There are two main uses for a ``Handler``: (1) to schedule messages and runnables to be executed as some point in the future; and (2) to enqueue an action to be performed on a different thread than your own.
+ Scheduling messages is accomplished with the ``post(Runnable)``, ``postAtTime(Runnable, long)``, ``postDelayed(Runnable, long)``, ``sendEmptyMessage(int)``, ``sendMessage(Message)``, ``sendMessageAtTime(Message, long)``, and ``sendMessageDelayed(Message, long)`` methods. The **post** versions allow you to enqueue ``Runnable`` objects to be called by the message queue when they are received; the ``sendMessage`` versions allow you to enqueue a ``Message`` object containing a bundle of data that will be processed by the Handler's ``handleMessage(Message)`` method (requiring that you implement a subclass of ``Handler``).