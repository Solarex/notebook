SQLite & ContentProvider
========================
+ SQLite supports the data types ``TEXT`` (similar to String in Java), ``INTEGER`` (similar to long in Java) and ``REAL`` (similar to double in Java). All other types must be converted into one of these fields before getting saved in the database. SQLite itself does not validate if the types written to the columns are actually of the defined type, e.g. you can write an integer into a string column and vice versa.
+ Access to an SQLite database involves accessing the file system. This can be slow. Therefore it is recommended to perform database operations asynchronously.If your application creates a database, this database is by default saved in the directory ``DATA/data/APP_NAME/databases/FILENAME``.The parts of the above directory are constructed based on the following rules. ``DATA`` is the path which the ``Environment.getDataDirectory()`` method returns. ``APP_NAME`` is your application name. ``FILENAME`` is the name you specify in your application code for the database.
+ To create and upgrade a database in your Android application you create a subclass of the ``SQLiteOpenHelper`` class. In the constructor of your subclass you call the ``super()`` method of ``SQLiteOpenHelper``, specifying the database name and the current database version.在``SQLiteOpenHelper``的子类中，指定数据库名和数据库版本。``onCreate()`` - is called by the framework, if the database is accessed but not yet created.``onUpgrade()`` - called, if the database version is increased in your application code. This method allows you to update an existing database schema or to drop the existing database and recreate it via the ``onCreate()`` method.The ``SQLiteOpenHelper`` class provides the ``getReadableDatabase()`` and ``getWriteableDatabase()`` methods to get access to an ``SQLiteDatabase`` object; either in read or write mode.
+ It is good practice to create a separate class per table. This class defines static ``onCreate()`` and ``onUpgrade()`` methods. These methods are called in the corresponding methods of ``SQLiteOpenHelper``. This way your implementation of ``SQLiteOpenHelper`` stays readable, even if you have several tables.为每个表创建一个SQLiteOpenHelper的子类。
+ 为数据库的每个表创建一个基于``SQLiteOpenHelper``的子类，在子类中实现``onCreate()``和``onUpgrade()``方法来创建表和升级表。``onCreate()``方法会被框架调用，如果数据库被访问且没有被创建就会创建数据库，一般在``onCreate()``方法中会创建表。
+ 从``SQLiteOpenHelper``的子类的``getReadableDatabase()``或者``getWriteableDatabase()``方法中可以得到``SQLiteDatabase``的实例。``SQLiteDatabase``提供了一系列操纵数据库表的方法。``SQLiteDatabase`` is the base class for working with a SQLite database in Android and provides methods to open, query, update and close the database.More specifically SQLiteDatabase provides the ``insert()``, ``update()`` and ``delete()`` methods.In addition it provides the ``execSQL()`` method, which allows to execute an SQL statement directly.The object ``ContentValues`` allows to define key/values. The key represents the table column identifier and the value represents the content for the table record in this column. ``ContentValues`` can be used for inserts and updates of database entries.``ContentValues``可以被用来插入数据库表中或者更新数据库表中的项。Queries can be created via the ``rawQuery()`` and ``query()`` methods or via the ``SQLiteQueryBuilder`` class .数据库查询可以通过``SQLiteDatabase``的``rawQuery()``或``query()``方法，也可以通过``SQLiteQueryBuilder``来构建查询。``rawQuery()`` directly accepts an SQL select statement as input.``query()`` provides a structured interface for specifying the SQL query.``SQLiteQueryBuilder`` is a convenience class that helps to build SQL queries.
+ A query returns a ``Cursor`` object. A ``Cursor`` represents the result of a query and basically points to one row of the query result. This way Android can buffer the query results efficiently; as it does not have to load all data into memory.一次查询返回的``Cursor``对象代表查询的结果并且指向结果中的一行。这样Android就可以有效缓存查询结果，因为它不必把所有的结果都装载到内存中。To get the number of elements of the resulting query use the ``getCount()``method.To move between individual data rows, you can use the ``moveToFirst()`` and ``moveToNext()`` methods. The ``isAfterLast()`` method allows to check if the end of the query result has been reached.在查询结果中游动(SQL中的游标)可以得到所有的查询结果。``Cursor`` provides typed ``get*()`` methods, e.g. ``getLong(columnIndex)``, ``getString(columnIndex)`` to access the column data for the current position of the result. The "columnIndex" is the number of the column you are accessing.使用``get*(columnIndex)``可以得到当前行第columnIndex列的数据。``Cursor`` also provides the ``getColumnIndexOrThrow(String)`` method which allows to get the column index for a column name of the table.``Cursor``也提供了``getColumnIndexOrThrow(String)``的方法来得到columnIndex，需要传入的是列名。A Cursor needs to be closed with the ``close()`` method call.
+ 呈现数据。``ListViews`` are Views which allow to display a list of elements.``ListActivities`` are specialized activities which make the usage of ``ListViews`` easier.To work with databases and ListViews you can use the ``SimpleCursorAdapter``. The ``SimpleCursorAdapter`` allows to set a layout for each row of the ListViews.``SimpleCursorAdapter``将从``Cursor``得到的每一行数据映射到``ListView``的每一行上。You also define an array which contains the column names and another array which contains the IDs of Views which should be filled with the data.要使用``SimpleCursorAdapter``需要两个映射数组，一个数组中是数据库表中的列名，一个是数据库表中每一列要映射到``ListView``每一行中组件的ID号。The ``SimpleCursorAdapter`` class will map the columns to the Views based on the ``Cursor`` passed to it.To obtain the ``Cursor`` you should use the ``Loader`` class.
+ 删除数据时，如果``Adapter``中不移除数据，底层的数据库删除不会执行，执行``database.delete()``返回0，表明0行被删除。
+ While a content provider can be used within an application to access data, its is typically used to share data with other application. As application data is by default private, a content provider is a convenient to share you data with other application based on a structured interface.The access to a content provider is done via an ``URI``. The basis for the URI is defined in the declaration of the ``ContentProvider`` in the ``AndroidManifest.xml`` file via the ``android:authorities`` attribute.As it is required to know the URIs of an content providers to access it, it is good practice to provide public constants for the URIs to document them to other developers.应该将``ContentProvider``的URI暴露给开发者供开发者使用。
+ To create your own ``ContentProvider`` you have to define a class which extends ``android.content.ContentProvider``. You also declare your ``ContentProvider`` in the ``AndroidManifest.xml`` file. This entry must specify the ``android:authorities`` attribute which allows to **identify** the ``ContentProvider``. This authority is the basis for the URI to access data and must be unique.
+ Until Android version 4.2 a content provider is by default available to other Android applications. As of Android 4.2 a content provider must be explicitly exported.To set the visibility of your content provider use the ``android:exported=false|true`` parameter in the declaration of your content provider in the ``AndroidManifest.xml`` file.
+ If you work directly with databases and have multiple writers from different threads you may run into concurrency issues.The ``ContentProvider`` can be accessed from several programs at the same time, therefore you must implement the access thread-safe. The easiest way is to use the keyword ``synchronized`` in front of all methods of the ``ContentProvider``, so that only one thread can access these methods at the same time.If you do not require that Android synchronizes data access to the ``ContentProvider``, set the ``android:multiprocess=true`` attribute in your ``<provider>`` definition in the ``AndroidManifest.xml`` file. This permits an instance of the provider to be created in each client process, eliminating the need to perform interprocess communication (IPC).如果创建的``ContentProvider``要同时被多个线程访问写入数据，应该保证线程安全，最简单的办法就是在``ContentProvider``的各个方法前面加入``synchronized``关键字来保证同一时刻只有一个线程访问。如果在``ContentProvider``中没有临界区数据，可以在``<provider>``中设置``android:multiprocess=true`` 属性，来确保只有一个``ContenProvider``实例被创建，这样就避免了每个访问``ContentProvider``的进程都创建一个``ContenProvider``实例，减少了IPC的开销。
+ The ``Loader`` class allow you to load data asynchronously in an activity or fragment. They can monitor the source of the data and deliver new results when the content changes. They also persist data between configuration changes.If the result is retrieved by the ``Loader`` after the object has been disconnected from its parent (activity or fragment), it can cache the data.You can use the abstract ``AsyncTaskLoader`` class as the basis for your own Loader implementations.The ``LoaderManager`` of an activity or fragment manages one or more Loader instances. The creation of a ``Loader`` is done via the following method call:``getLoaderManager().initLoader(0, null, this); ``.The first parameter is a unique ID which can be used by the callback class to identify that Loader later. The second parameter is a ``bundle`` which can be given to the callback class for more information.The third parameter of ``initLoader()`` is the class which is called once the initialization has been started (callback class). This class must implement the ``LoaderManager.LoaderCallbacks`` interface. It is good practice that an ``activity`` or the ``fragment`` which uses a ``Loader`` implements the ``LoaderManager.LoaderCallbacks`` interface.每个使用``Loader``的``Activity``或``Fragment``都要实现``LoaderManager.LoaderCallbacks``接口。The ``Loader`` is not directly created by the ``getLoaderManager().initLoader()`` method call, but must be created by the callback class in the ``onCreateLoader()`` method.Once the Loader has finished reading data asynchronously, the ``onLoadFinished()`` method of the callback class is called. Here you can update your user interface.