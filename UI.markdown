Guide_Developer.Android
========================
##UI User Interface
###Settings
+ You must save the XML file in the ``res/xml/`` directory. Although you can name the file anything you want, it's traditionally named ``preferences.xml``. You usually need only one file, because branches in the hierarchy (that open their own list of settings) are declared using nested instances of ``PreferenceScreen``.If you want to create a multi-pane layout for your settings, then you need separate XML files for each fragment.The root node for the XML file must be a ``<PreferenceScreen>`` element. Within this element is where you add each ``Preference``. Each child you add within the ``<PreferenceScreen>`` element appears as a single item in the list of settings.
+ In rare cases, you might want to design your settings such that the first screen displays only a list of ``subscreens`` (such as in the system Settings app). When you're developing such a design for Android 3.0 and higher, you should use a new "headers" feature in Android 3.0, instead of building subscreens with nested ``PreferenceScreen`` elements.To build your settings with headers, you need to:
	+ Separate each group of settings into separate instances of ``PreferenceFragment``. That is, each group of settings needs a separate XML file.
	+ Create an XML headers file that lists each settings group and declares which fragment contains the corresponding list of settings.
	+ Extend the ``PreferenceActivity`` class to host your settings.
	+ Implement the ``onBuildHeaders()`` callback to specify the headers file.
Each group of settings in your list of headers is specified by a single ``<header>`` element inside a root ``<preference-headers>`` element.
The ``<extras>`` element allows you to pass key-value pairs to the ``fragment`` in a ``Bundle``. The fragment can retrieve the arguments by calling ``getArguments()``. You might pass arguments to the fragment for a variety of reasons, but one good reason is to reuse the same subclass of ``PreferenceFragment`` for each group and use the argument to specify which preferences XML file the fragment should load.
+ To display the preference headers, you must implement the ``onBuildHeaders()`` callback method and call ``loadHeadersFromResource()``.
+ Beginning with Android 4.0, the system's Settings application allows users to see how much network data their applications are using while in the foreground and background. Users can then disable the use of background data for individual apps. In order to avoid users disabling your app's access to data from the background, you should use the data connection efficiently and allow users to refine your app's data usage through your application settings.从4.0开始，系统设置允许用户查看应用程序在前台和后台用了多少流量，用户可以禁止单独应用后台使用流量。为了避免用户禁止你的应用程序后台访问网络，你的应该应该合理使用网络并且允许用户通过应用的设置来改善流量使用，如多久进行一次数据同步，是否只在WIFI下进行上传下载操作，是否在漫游的时候使用网络等。Once you've added the necessary preferences in your ``PreferenceActivity`` to control your app's data habits, you should add an intent filter for ``ACTION_MANAGE_NETWORK_USAGE`` in your manifest file.
+ When you extend the ``Preference``class, there are a few important things you need to do:
	+ Specify the user interface that appears when the user selects the settings. If you directly extend the ``Preference`` class, you need to implement ``onClick()`` to define the action that occurs when the user selects the item. However, most custom settings extend ``DialogPreference`` to show a dialog, which simplifies the procedure. When you extend ``DialogPreference``, you must call ``setDialogLayoutResourcs()`` during in the class constructor to specify the layout for the dialog.
	+ Save the setting's value when appropriate.You can save a value for the setting at any time by calling one of the Preference class's ``persist*()`` methods, such as ``persistInt()`` if the setting's value is an integer or ``persistBoolean()`` to save a boolean.Calling ``persist*()`` saves the value to the ``SharedPreferences`` file (automatically using the key that's specified in the XML file for this ``Preference``).
	+ Initialize the Preference with the current (or default) value when it comes into view. When the system adds your Preference to the screen, it calls ``onSetInitialValue()`` to notify you whether the setting has a persisted value. If there is no persisted value, this call provides you the default value.
	+ Provide the default value when requested by the system.If the instance of your ``Preference`` class specifies a default value (with the ``android:defaultValue`` attribute), then the system calls ``onGetDefaultValue()`` when it instantiates the object in order to retrieve the value. You must implement this method in order for the system to save the default value in the ``SharedPreferences``.The method arguments provide everything you need: the array of attributes and the index position of the ``android:defaultValue``, which you must retrieve. The reason you must implement this method to extract the default value from the attribute is because you must specify a local default value for the attribute in case the value is undefined.如果value没有定义默认值，需要使用一个本地的默认值返回。
	+ If the Preference provides its own UI (such as a dialog), save and restore the state to handle lifecycle changes (such as when the user rotates the screen).Just like a View in a layout, your Preference subclass is responsible for saving and restoring its state in case the activity or fragment is restarted (such as when the user rotates the screen). To properly save and restore the state of your Preference class, you must implement the lifecycle callback methods ``onSaveInstanceState()`` and ``onRestoreInstanceState()``.The state of your Preference is defined by an object that implements the ``Parcelable`` interface. The Android framework provides such an object for you as a starting point to define your state object: the ``Preference.BaseSavedState`` class.To define how your ``Preference`` class saves its state, you should extend the ``Preference.BaseSavedState`` class. You need to override just a few methods and define the ``CREATOR`` object.