#Guide_Developer.Android
##App Components
###App Fundamentals
+ Android两个不同应用共享数据，应用访问系统服务：It's possible to arrange for two applications to share the same Linux user ID, in which case they are able to access each other's files. To conserve system resources, applications with the same user ID can also arrange to run in the same Linux process and share the same VM (the applications must also be signed with the same certificate).有可能安排两个应用共用一个linux系统ID，在那种情况下，它们能互相访问相互的数据。为了节约系统资源,拥用相同用户ID的应用，可能也被安排运行在同一个Linux进程中并共享相同的VM(应用必须被签名成同样的认证)。An application can request permission to access device data such as the user's contacts, SMS messages, the mountable storage (SD card), camera, Bluetooth, and more. All application permissions must be granted by the user at install time.所用应用能请求允许访问硬件数据，比如像用户通信录，SMS消息及可挂载的存储设备(SD card),摄像头,蓝牙等,所有应用的权限必须在用户安装时被许可。
+ 4个组件中的其中三个组件---activities,serivces,和broadcast receivers----是被叫做intent的异步消息激活的.在运行时,Intents把某个的组件与其他的组件互相邦定，而不管这个组件是否属于你的应用还是其他的应用(你可以把它们想像成一个消息，用于请求一个其他组件的动作).一个intent是一个由Intent创建的对象.该对象定义了一个激活某个特定组件或者某个组件类型的消息,一个intent可以是显示的，同样,也可以是隐式的.
+ 对于activities和services，一个intent(意图)定义了一个要执行的动作(比如：to”view”或"send" 些什么),并指定了要采用的URI格式的数据(其中一些，是其他组件启动所需要知道的).比如，一个intent可能传送一个请求给一个activity，要显示一张图片或打开一个网页.在有些情况,你启动一个activity接收一个结果,这种情况下，activity将在Intent中返回一个结果.(比如，你可以指示一个intent，让用户取一个人的联系方式，并返回给你，返回的intent中会包含一个指向选定联系方式的URI.)
+ There are separate methods for activating each type of component激活四大组件的不同方法:
  + You can start an activity (or give it something new to do) by passing an Intent to startActivity() or startActivityForResult() (when you want the activity to return a result).
  + You can start a service (or give new instructions to an ongoing service) by passing an Intent to startService(). Or you can bind to the service by passing an Intent to bindService().
  + You can initiate a broadcast by passing an Intent to methods like sendBroadcast(), sendOrderedBroadcast(), or sendStickyBroadcast().
  + You can perform a query to a content provider by calling query() on a ContentResolver.
+ Activities, services, and content providers that you include in your source but do not declare in the manifest are not visible to the system and, consequently, can never run. However, broadcast receivers can be either declared in the manifest or created dynamically in code (as ``BroadcastReceiver`` objects) and registered with the system by calling ``registerReceiver()``. Activities, services, 和 content providers如果只在代码中实现而没有在AndroidManifest.xml文件中声明，就不会被系统可见，所以也就不会被运行。BroadcastReceiver可以在AndroidManifest.xml文件中注册或者在代码中动态注册。Before the Android system can start an application component, the system must know that the component exists by reading the application's AndroidManifest.xml file (the "manifest" file). Your application must declare all its components in this file, which must be at the root of the application project directory.在系统激活一个应用程序的某个组件之前，系统通过应用程序的AndroidManifest.xml文件来获知应用程序中的组件。
+ The real power of intents lies in the concept of intent actions. With intent actions, you simply describe the type of action you want to perform (and optionally, the data upon which you’d like to perform the action) and allow the system to find a component on the device that can perform the action and start it. If there are multiple components that can perform the action described by the intent, then the user selects which one to use.Intent的真正威力在``Intent Actions``。在Intent Actions中，只需描述想要执行的操作，系统就会找到可以执行这项操作的组件然后激活这个主键。如果有多个组件可以执行Intent描述的操作，系统会让用户选择使用哪个组件来执行这项操作。The way the system identifies the components that can respond to an intent is by comparing the intent received to the intent filters provided in the manifest file of other applications on the device.系统判断一个组件是否可以响应一个intent的方法是比较接收到的intent和其他应用程序AndroidManifest.xml中组件的``<intent-filter>``标签。When you declare a component in your application's manifest, you can optionally include intent filters that declare the capabilities of the component so it can respond to intents from other applications. You can declare an intent filter for your component by adding an <intent-filter> element as a child of the component's declaration element.

###Activities
+ The activity window typically fills the screen, but may be smaller than the screen and float on top of other windows.一个Activity窗口通常布满整个窗口，但也可能比窗口小或者悬浮在其他窗口上。
+ ``onPause()``The system calls this method as the first indication that the user is leaving your activity (though it does not always mean the activity is being destroyed). This is usually where you should commit any changes that should be persisted beyond the current user session (because the user might not come back).在``onPause``方法中commit changes并且存储下来，因为用户可能不回来了。
+ "Layouts" are views derived from ``ViewGroup`` that provide a unique layout model for its child views, such as a linear layout, a grid layout, or relative layout. You can also subclass the ``View`` and ``ViewGroup`` classes (or existing subclasses) to create your own widgets and layouts and apply them to your activity layout.ou can set the layout as the UI for your activity with ``setContentView()``, passing the resource ID for the layout. However, you can also create new Views in your activity code and build a view hierarchy by inserting new ``View``s into a ``ViewGroup``, then use that layout by passing the root ``ViewGroup`` to ``setContentView()``.
+ An ``<activity>`` element can also specify various intent filters—using the ``<intent-filter>`` element—in order to declare how other application components may activate it.一个activity可以声明intent filter属性来告知系统其他应用程序可以怎样激活它。If you intend for your application to be self-contained and not allow other applications to activate its activities, then you don't need any other intent filters. 一个Activity如果只是被包含在应用程序中并且不希望被其他应用程序激活，那它可以不包含任何intent filter。Only one activity should have the "main" action and "launcher" category. Activities that you don't want to make available to other applications should have no intent filters and you can start them yourself using explicit intents (as discussed in the following section).
+ If you want your activity to respond to implicit intents that are delivered from other applications (and your own), then you must define additional intent filters for your activity. For each type of intent to which you want to respond, you must include an <intent-filter> that includes an <action> element and, optionally, a <category> element and/or a <data> element. These elements specify the type of intent to which your activity can respond.如果想要Activity被其他应用程序或自身应用程序隐式调用，必须为这个Activity定义intent filter。
+ You can start another activity by calling ``startActivity()``, passing it an Intent that describes the activity you want to start. The intent specifies either the exact activity you want to start or describes the type of action you want to perform (and the system selects the appropriate activity for you, which can even be from a different application). An intent can also carry small amounts of data to be used by the activity that is started.
+ Sometimes, you might want to receive a result from the activity that you start. In that case, start the activity by calling startActivityForResult() (instead of startActivity()). To then receive the result from the subsequent activity, implement the onActivityResult() callback method. When the subsequent activity is done, it returns a result in an Intent to your onActivityResult() method.
+ ``Paused``,Another activity is in the foreground and has focus, but this one is still visible. That is, another activity is visible on top of this one and that activity is partially transparent or doesn't cover the entire screen. A paused activity is completely alive (the Activity object is retained in memory, it maintains all state and member information, and remains attached to the window manager), but can be killed by the system in extremely low memory situations.在``Paused``状态下，其他Activity在当前Activity前面部分挡住了当前Activity。一个paused activity是存活的，被保留在内存中，**并且和窗口管理器绑定在一起**，但是当系统内存较低时可以杀死这个activity。
+ ``Stopped``,The activity is completely obscured by another activity (the activity is now in the "background"). A stopped activity is also still alive (the Activity object is retained in memory, it maintains all state and member information, but is not attached to the window manager). However, it is no longer visible to the user and it can be killed by the system when memory is needed elsewhere.当前activity完全被其他activity挡住了，一个stoped activity还是存活的，被保留在内存中，**但是没有和窗口管理器绑定在一起**。这个activity对用户不可见，在内存较少时会被杀掉。
+ If an activity is paused or stopped, the system can drop it from memory either by asking it to finish (calling its finish() method), or simply killing its process. When the activity is opened again (after being finished or killed), it must be created all over.
+ The entire lifetime of an activity happens between the call to onCreate() and the call to onDestroy(). Your activity should perform setup of "global" state (such as defining layout) in onCreate(), and release all remaining resources in onDestroy(). For example, if your activity has a thread running in the background to download data from the network, it might create that thread in onCreate() and then stop the thread in onDestroy().在entire lifetime中，及onCreate和onDestory之间，应该在onCreate中建立全局的状态，在onDestory中释放资源。
+ The visible lifetime of an activity happens between the call to onStart() and the call to onStop(). During this time, the user can see the activity on-screen and interact with it. For example, onStop() is called when a new activity starts and this one is no longer visible. Between these two methods, you can maintain resources that are needed to show the activity to the user. For example, you can register a BroadcastReceiver in onStart() to monitor changes that impact your UI, and unregister it in onStop() when the user can no longer see what you are displaying. The system might call onStart() and onStop() multiple times during the entire lifetime of the activity, as the activity alternates between being visible and hidden to the user.可见生命周期在onStart和onStop之间，在这之间可以管理需要呈现给用户的资源。
+ The foreground lifetime of an activity happens between the call to onResume() and the call to onPause(). During this time, the activity is in front of all other activities on screen and has user input focus. An activity can frequently transition in and out of the foreground—for example, onPause() is called when the device goes to sleep or when a dialog appears. Because this state can transition often, the code in these two methods should be fairly lightweight in order to avoid slow transitions that make the user wait.获得用户焦点生命周期是在``onResume``和``onPause``之间，在此期间，这个activity在所有其他activity之前而且获得用户焦点。一个Activity会经常在这两种状态之间切换，所以在这两个回调方法中的代码应该尽量轻量级。避免在切换状态时出现卡顿现象。
+ ``onCreate`` is where you should do all of your normal static set up — create views, bind data to lists, and so on. This method is passed a Bundle object containing the activity's previous state, if that state was captured
+ ``onPause`` is typically used to commit unsaved changes to persistent data, stop animations and other things that may be consuming CPU, and so on. It should do whatever it does very quickly, because the next activity will not be resumed until it returns.
+ ``onDestory`` is called before the activity is destroyed. This is the final call that the activity will receive. It could be called either because the activity is finishing (someone called finish() on it), or because the system is temporarily destroying this instance of the activity to save space. You can distinguish between these two scenarios with the isFinishing() method.
+ The system can kill the process hosting the activity at any time after the method (onPause(), onStop(), and onDestroy()) returns, without executing another line of the activity's code.Because onPause() is the first of the three, once the activity is created, onPause() is the last method that's guaranteed to be called before the process can be killed—if the system must recover memory in an emergency, then onStop() and onDestroy() might not be called. Therefore, you should use onPause() to write crucial persistent data (such as user edits) to storage. However, you should be selective about what information must be retained during onPause(), because any blocking procedures in this method block the transition to the next activity and slow the user experience.``onPause``是在activity进程被杀死之前最后一个保证会被系统调用的方法，因为如果系统需要紧急回收内存，``onStop``和``onDestory``方法可能不会被调用。因此，应该使用``onPause``去保存重要的信息，在重要信息保存中需要有选择性，这个方法中任何阻塞的过程都会延迟切换到下一个activity，影响用户体验。
+ when an activity is paused or stopped, the state of the activity is retained. This is true because the Activity object is still held in memory when it is paused or stopped—all information about its members and current state is still alive. Thus, any changes the user made within the activity are retained so that when the activity returns to the foreground (when it "resumes"), those changes are still there.当一个activity pause 或者 stop的时候，它的状态会被保存，这样activity返回到前台的时候用户输入的信息仍然可以显现出来。When the system destroys an activity in order to recover memory, the Activity object is destroyed, so the system cannot simply resume it with its state intact. Instead, the system must recreate the Activity object if the user navigates back to it. Yet, the user is unaware that the system destroyed the activity and recreated it and, thus, probably expects the activity to be exactly as it was. In this situation, you can ensure that important information about the activity state is preserved by implementing an additional callback method that allows you to save information about the state of your activity: ``onSaveInstanceState()``.当系统杀死activity时，系统不能简单地恢复它的状态，系统必须重新创建activity。为了不影响用户体验，可以使用``onSaveInstanceState``来保存用户的数据并且恢复它。
+ The system calls ``onSaveInstanceState()`` before making the activity vulnerable to destruction. The system passes this method a Bundle in which you can save state information about the activity as name-value pairs, using methods such as putString() and putInt(). Then, if the system kills your application process and the user navigates back to your activity, the system recreates the activity and passes the Bundle to both onCreate() and onRestoreInstanceState(). Using either of these methods, you can extract your saved state from the Bundle and restore the activity state. If there is no state information to restore, then the Bundle passed to you is null (which is the case when the activity is created for the first time).系统在杀死activity之前会调用``onSaveInstanceState``，如果系统杀死了activity之后用户又返回到这个activity，系统会重新创建这个activity，并且会把保存的信息传递给``onCreate``和``onRestoreInstanceState``方法。There's no guarantee that onSaveInstanceState() will be called before your activity is destroyed, because there are cases in which it won't be necessary to save the state (such as when the user leaves your activity using the Back button, because the user is explicitly closing the activity). If the system calls onSaveInstanceState(), it does so before onStop() and possibly before onPause().系统不保证在activity被杀死之前调用``onSaveInstanceState``，因为有时没必要保存状态。However, even if you do nothing and do not implement onSaveInstanceState(), some of the activity state is restored by the Activity class's default implementation of onSaveInstanceState(). Specifically, the default implementation calls the corresponding onSaveInstanceState() method for every View in the layout, which allows each view to provide information about itself that should be saved. Almost every widget in the Android framework implements this method as appropriate, such that any visible changes to the UI are automatically saved and restored when your activity is recreated. For example, the EditText widget saves any text entered by the user and the CheckBox widget saves whether it's checked or not. The only work required by you is to provide a unique ID (with the android:id attribute) for each widget you want to save its state. If a widget does not have an ID, then the system cannot save its state.即使不实现``onSaveInstanceState``，一些activity状态也会被保存。默认的``onSaveInstanceState``方法调用layout中的每个view的``onSaveInstanceState``方法，这些view的``onSaveInstanceState``方法会提供自身需要被保存的信息。几乎Android Framework中的每个组件都实现了``onSvaeInstanceState``方法，这样activity的UI会被自动保存，自动恢复。为了使layout中的view自动保存，自动恢复自己的状态，应该给每个你希望自动保存自动恢复的view一个id。如果一个view没有id，系统不会保存它的状态。
+ You can also explicitly stop a view in your layout from saving its state by setting the android:saveEnabled attribute to "false" or by calling the setSaveEnabled() method. Usually, you should not disable this, but you might if you want to restore the state of the activity UI differently.可以通过设置``android:saveEnabled``属性为``false``或者调用view的``setSaveEnabled``方法来显式阻止layout中的一个view保存自身状态。Because the default implementation of onSaveInstanceState() helps save the state of the UI, if you override the method in order to save additional state information, you should always call the superclass implementation of onSaveInstanceState() before doing any work. Likewise, you should also call the superclass implementation of onRestoreInstanceState() if you override it, so the default implementation can restore view states.重写方法前记得调用super的对应方法。
+ Because onSaveInstanceState() is not guaranteed to be called, you should use it only to record the transient state of the activity (the state of the UI)—you should never use it to store persistent data. Instead, you should use onPause() to store persistent data (such as data that should be saved to a database) when the user leaves the activity.``onSaveInstanceState``方法不保证会被调用，所以应该只用它来保存瞬时的数据，比如UI的状态，而不应该用来保存持久化数据，比如写入数据到数据库中，这些持久化数据的操作应该在``onPause``方法中实现。
+ Some device configurations can change during runtime (such as screen orientation, keyboard availability, and language). When such a change occurs, Android recreates the running activity (the system calls onDestroy(), then immediately calls onCreate()). This behavior is designed to help your application adapt to new configurations by automatically reloading your application with alternative resources that you've provided (such as different layouts for different screen orientations and sizes).The best way to handle such a restart is to save and restore the state of your activity using onSaveInstanceState() and onRestoreInstanceState() (or onCreate()), as discussed in the previous section.Activity配置信息改变的时候，系统会重新创建activity，先调用``onDestory``然后马上调用``onCreate``以响应配置信息的更改。最好在``onSaveInstanceState``中保存信息，在``onRestoreInstanceState``中恢复信息来保证用户体验一致。
+ The order of lifecycle callbacks is well defined, particularly when the two activities are in the same process and one is starting the other. Here's the order of operations that occur when Activity A starts Acivity B:
  + Activity A's onPause() method executes.
  + Activity B's onCreate(), onStart(), and onResume() methods execute in sequence. (Activity B now has user focus.)
  + Then, if Activity A is no longer visible on screen, its onStop() method executes.
This predictable sequence of lifecycle callbacks allows you to manage the transition of information from one activity to another. For example, if you must write to a database when the first activity stops so that the following activity can read it, then you should write to the database during ``onPause()`` instead of during ``onStop()``.Activity A激活Activity B的顺序是既定的，可预测的，因此，如果需要Activity A写入数据库以供Activity B 共享其中的数据，那么操作应该在Activity A 的``onPause``方法中发生，而不是在Activity A的``onStop``方法中。

####Fragment
+ When you add a fragment as a part of your activity layout, it lives in a ViewGroup inside the activity's view hierarchy and the fragment defines its own view layout. You can insert a fragment into your activity layout by declaring the fragment in the activity's layout file, as a <fragment> element, or from your application code by adding it to an existing ViewGroup. However, a fragment is not required to be a part of the activity layout; you may also use a fragment without its own UI as an invisible worker for the activity.可以在layout的xml文件中，以``<fragment>``元素的形式声明fragment，也可以直接在代码中添加。但是一个fragment不一定得是activity的一部分，可以使用一个没有UI的fragment为activity服务。
+ Usually, you should implement at least the following lifecycle methods:
  + ``onCreate()`` The system calls this when creating the fragment. Within your implementation, you should initialize essential components of the fragment that you want to retain when the fragment is paused or stopped, then resumed.
  + ``onCreateView()`` The system calls this when it's time for the fragment to draw its user interface for the first time. To draw a UI for your fragment, you must return a View from this method that is the root of your fragment's layout. You can return null if the fragment does not provide a UI.返回一个View。
  + ``onPause()`` The system calls this method as the first indication that the user is leaving the fragment (though it does not always mean the fragment is being destroyed). This is usually where you should commit any changes that should be persisted beyond the current user session (because the user might not come back).数据持久化的好时机。

+　To provide a layout for a fragment, you must implement the onCreateView() callback method, which the Android system calls when it's time for the fragment to draw its layout. Your implementation of this method must return a View that is the root of your fragment's layout.在``onCreateView``中提供fragment的UI，应该返回fragment的root view。If your fragment is a subclass of ListFragment, the default implementation returns a ListView from onCreateView(), so you don't need to implement it.像``ListActivity``一样，直接绑定adapter即可，不用再创建返回view。
+ The ``android:name`` attribute in the ``<fragment>`` specifies the Fragment class to instantiate in the layout.When the system creates this activity layout, it instantiates each fragment specified in the layout and calls the ``onCreateView()`` method for each one, to retrieve each fragment's layout. The system inserts the View returned by the fragment directly in place of the ``<fragment>`` element.系统创建activity的布局的时候，实例化每个``<fragment>``元素中的类，调用它们的``onCreateView``方法，并把``onCreateView``返回的View插入到``<fragment>``元素的位置。
+ Each fragment requires a unique identifier that the system can use to restore the fragment if the activity is restarted (and which you can use to capture the fragment to perform transactions, such as remove it). There are three ways to provide an ID for a fragment:Supply the ``android:id`` attribute with a unique ID.Supply the ``android:tag`` attribute with a unique string.If you provide neither of the previous two, the system uses the ID of the container view.给每个fragment提供一个id或tag来方便系统恢复他的状态。如果没有提供``android:id``属性也没有提供``android:tag``属性，系统将使用包含这个fragment的view的id。
+ At any time while your activity is running, you can add fragments to your activity layout. You simply need to specify a ViewGroup in which to place the fragment.在activity运行的任意时刻，可以添加fragment到activity中，只需要指定放置fragment的view组件即可。
+ Some things that you can do with FragmentManager include:
  + Get fragments that exist in the activity, with ``findFragmentById()`` (for fragments that provide a UI in the activity layout) or ``findFragmentByTag()`` (for fragments that do or don't provide a UI).
  + Pop fragments off the back stack, with ``popBackStack()`` (simulating a Back command by the user).
  + Register a listener for changes to the back stack, with ``addOnBackStackChangedListener()``.
+ Before you call commit(), however, you might want to call addToBackStack(), in order to add the transaction to a back stack of fragment transactions. This back stack is managed by the activity and allows the user to return to the previous fragment state, by pressing the Back button.back stack被activity管理，允许用户通过点击back按钮返回前一个fragment状态。
+ If you do not call addToBackStack() when you perform a transaction that removes a fragment, then that fragment is destroyed when the transaction is committed and the user cannot navigate back to it. Whereas, if you do call addToBackStack() when removing a fragment, then the fragment is stopped and will be resumed if the user navigates back.在remove掉一个fragment后，如果没有调用``addToBackStack``，那么这个fragment会被销毁掉，如果调用了，这个fragment会被停止，当用户返回的时候会resume。For each fragment transaction, you can apply a transition animation, by calling setTransition() before you commit.
+ Calling commit() does not perform the transaction immediately. Rather, it schedules it to run on the activity's UI thread (the "main" thread) as soon as the thread is able to do so. If necessary, however, you may call executePendingTransactions() from your UI thread to immediately execute transactions submitted by commit(). Doing so is usually not necessary unless the transaction is a dependency for jobs in other threads.可以在UI线程调用``executePendingTransactions``来立即执行``FragmentManager``的``commit``，通常不用这样做，除非其他线程依赖这次FragmentManager的commit。Caution: You can commit a transaction using commit() only prior to the activity saving its state (when the user leaves the activity). If you attempt to commit after that point, an exception will be thrown. This is because the state after the commit can be lost if the activity needs to be restored. For situations in which its okay that you lose the commit, use commitAllowingStateLoss().必须在activity保存自己状态之前调用FragmentManager的commit，以免恢复activity的时候丢失fragment的状态。如果不关心这些丢失的状态，可以使用``commitAllowingStatLoss``。
+ In some cases, you might need a fragment to share events with the activity. A good way to do that is to define a callback interface inside the fragment and require that the host activity implement it. When the activity receives a callback through the interface, it can share the information with other fragments in the layout as necessary.为了响应fragment的事件，可以在fragment内部定义一个interface，然后包含这个fragment的activity实现这个接口中的方法，接着在fragment中的onAttach中将绑定的activity赋予内部变量，在事件触发代码中调用内部变量的方法，实际上就是调用activity实现的interface中的方法。
+ Your fragments can contribute menu items to the activity's Options Menu (and, consequently, the Action Bar) by implementing onCreateOptionsMenu(). In order for this method to receive calls, however, you must call setHasOptionsMenu() during onCreate(), to indicate that the fragment would like to add items to the Options Menu (otherwise, the fragment will not receive a call to onCreateOptionsMenu()).通过在fragment中的onCreat方法中调用setHasOptionsMenu方法，表明这个fragment期望添加item到options menu，否则这个fragment将不会收到onCreateOptionsMenu的调用，有了onCreateOptionsMenu的调用，这个fragment可以添加item到activity的options menu或者action bar。Any items that you then add to the Options Menu from the fragment are appended to the existing menu items. The fragment also receives callbacks to onOptionsItemSelected() when a menu item is selected.在fragment中添加的menu item被追加到已经存在的menu item后面，fragment也会收到onOptionsItemSelected方法的回调当一个menu item被选择的时候。You can also register a view in your fragment layout to provide a context menu by calling registerForContextMenu(). When the user opens the context menu, the fragment receives a call to onCreateContextMenu(). When the user selects an item, the fragment receives a call to onContextItemSelected().可以在fragment layout中注册一个view来提供上下文菜单。Although your fragment receives an on-item-selected callback for each menu item it adds, the activity is first to receive the respective callback when the user selects a menu item. If the activity's implementation of the on-item-selected callback does not handle the selected item, then the event is passed to the fragment's callback. This is true for the Options Menu and context menus.当菜单点击时，activity首先处理，如果activity没有处理对应的menu item点击事件，这个事件会传送到fragment的回调函数中。这适用于options menu和context menu。
+ Also like an activity, you can retain the state of a fragment using a Bundle, in case the activity's process is killed and you need to restore the fragment state when the activity is recreated. You can save the state during the fragment's onSaveInstanceState() callback and restore it during either onCreate(), onCreateView(), or onActivityCreated(). 可以在onSaveInstanceState中保存fragment的状态，在onCreate，onCreateView，onActivityCreated中恢复。
+ The most significant difference in lifecycle between an activity and a fragment is how one is stored in its respective back stack. An activity is placed into a back stack of activities that's managed by the system when it's stopped, by default (so that the user can navigate back to it with the Back button). However, a fragment is placed into a back stack managed by the host activity only when you explicitly request that the instance be saved by calling addToBackStack() during a transaction that removes the fragment.系统管理activity的back stack，host activity管理fragment的back stack，调用addToBackStack方法会将fragment状态保存到back stack中。
+  If you need a Context object within your Fragment, you can call getActivity(). However, be careful to call getActivity() only when the fragment is attached to an activity. When the fragment is not yet attached, or was detached during the end of its lifecycle, getActivity() will return null.fragment在onAttach之后调用getActivity才会返回host activity，否则，如果没有调用onAttach或者onDetach之后，调用getActivity之后会返回null。
+ Fragments have a few extra lifecycle callbacks, however, that handle unique interaction with the activity in order to perform actions such as build and destroy the fragment's UI. These additional callback methods are:
  + ``onAttach()``Called when the fragment has been associated with the activity (the Activity is passed in here).
  + ``onCreateView()``Called to create the view hierarchy associated with the fragment.
  + ``onActivityCreated()``Called when the activity's onCreate() method has returned.
  + ``onDestroyView()``Called when the view hierarchy associated with the fragment is being removed.
  + ``onDetach()``Called when the fragment is being disassociated from the activity.
+ Once the activity reaches the resumed state, you can freely add and remove fragments to the activity. Thus, only while the activity is in the resumed state can the lifecycle of a fragment change independently.

####Loaders
Introduced in Android 3.0, loaders make it easy to asynchronously load data in an ``activity`` or ``fragment``. Loaders have these characteristics:
  + They are available to every Activity and Fragment.
  + They provide asynchronous loading of data.
  + They monitor the source of their data and deliver new results when the content changes.
  + They automatically reconnect to the last loader's cursor when being recreated after a configuration change. Thus, they don't need to re-query their data.
+ Loader API
  + ``LoaderManager``An abstract class associated with an Activity or Fragment for managing one or more Loader instances. This helps an application manage longer-running operations in conjunction with the Activity or Fragment lifecycle; the most common use of this is with a CursorLoader, however applications are free to write their own loaders for loading other types of data. There is only one LoaderManager per activity or fragment. But a LoaderManager can have multiple loaders.一个和activity或者fragment联合起来管理Loader实例的抽象类。
  + ``LoaderManager.LoaderCallbacks``A callback interface for a client to interact with the LoaderManager. For example, you use the onCreateLoader() callback method to create a new loader.和``LoaderManager``互动的回调接口。
  + ``Loader``An abstract class that performs asynchronous loading of data. This is the base class for a loader. You would typically use CursorLoader, but you can implement your own subclass. While loaders are active they should monitor the source of their data and deliver new results when the contents change.
  + ``AsyncTaskLoader``Abstract loader that provides an AsyncTask to do the work.
  + ``CursorLoader``A subclass of ``AsyncTaskLoader`` that queries the ``ContentResolver`` and returns a ``Cursor``. This class implements the ``Loader`` protocol in a standard way for querying cursors, building on ``AsyncTaskLoader to perform the cursor query on a background thread so that it does not block the application's UI. Using this loader is the best way to asynchronously load data from a ``ContentProvider``, instead of performing a managed query through the fragment or activity's APIs.

+ An application that uses loaders typically includes the following:
  + An Activity or Fragment.
  + An instance of the LoaderManager.
  + A CursorLoader to load data backed by a ``ContentProvider``. Alternatively, you can implement your own subclass of ``Loader`` or ``AsyncTaskLoader`` to load data from some other source.
  + An implementation for ``LoaderManager.LoaderCallbacks``. This is where you create new loaders and manage your references to existing loaders.
  + A way of displaying the loader's data, such as a ``SimpleCursorAdapter``.
  + A data source, such as a ``ContentProvider``, when using a ``CursorLoader``.
一个使用``Loader``的应用需要有以下：一个activity或者fragment，activity或fragment中取得``LoaderManager``，一个``CursorLoader``来加载由``ContentProvider``提供的数据，当然也可以自己实现``Loader``或者``AsyncTaskLoader``的子类，实现``LoaderManager.LoaderCallbacks``回调方法，在这里可以创建loader并引用它，展现数据的方式，比如``SimpleCursorAdapter``，给``Loader``如``CursorLoader``提供数据的数据源，如``ContentProvier``。
+ The LoaderManager manages one or more Loader instances within an Activity or Fragment. There is only one LoaderManager per activity or fragment.``LoadManager``管理一个或者多个在activity或者fragment中的Loader实例。You typically initialize a Loader within the activity's ``onCreate()`` method, or within the fragment's ``onActivityCreated()`` method. You do this as follows:``getLoaderManager().initLoader(0, null, this);``，一般在activity中的``onCreate``或者fragment的``onActivityCreated``中初始化loader。
+ In either case, the given ``LoaderManager.LoaderCallbacks`` implementation is associated with the loader, and will be called when the loader state changes. If at the point of this call the caller is in its started state, and the requested loader already exists and has generated its data, then the system calls ``onLoadFinished()`` immediately (during ``initLoader()``), so you must be prepared for this to happen.``LoaderManager.LoaderCallbacks``和``Loader``绑定在一起，在``Loader``状态发生变化的时候会被调用。
+ Note that the initLoader() method returns the Loader that is created, but you don't need to capture a reference to it. The LoaderManager manages the life of the loader automatically. The LoaderManager starts and stops loading when necessary, and maintains the state of the loader and its associated content. As this implies, you rarely interact with loaders directly,You most commonly use the LoaderManager.LoaderCallbacks methods to intervene in the loading process when particular events occur.让LoaderManager自动管理loader的生命周期。
+ When you use initLoader(), as shown above, it uses an existing loader with the specified ID if there is one. If there isn't, it creates one. But sometimes you want to discard your old data and start over.To discard your old data, you use restartLoader().在initLoader的时候，如果loader ID存在，则返回，不存在则创建，有时候想要丢弃已经创建的loader的数据，可以使用restartLoader。
+ ``LoaderManager.LoaderCallbacks`` is a callback interface that lets a client interact with the LoaderManager.Loaders, in particular CursorLoader, are expected to retain their data after being stopped. This allows applications to keep their data across the activity or fragment's onStop() and onStart() methods, so that when users return to an application, they don't have to wait for the data to reload. You use the LoaderManager.LoaderCallbacks methods to know when to create a new loader, and to tell the application when it is time to stop using a loader's data.``LoaderManager.Loaders``是和``LoaderManager``进行交互的回调方法。
+ LoaderManager.LoaderCallbacks includes these methods:
  + ``onCreateLoader()`` — Instantiate and return a new Loader for the given ID.When you attempt to access a loader (for example, through ``initLoader()``), it checks to see whether the loader specified by the ID exists. If it doesn't, it triggers the ``LoaderManager.LoaderCallbacks`` method ``onCreateLoader()``. This is where you create a new loader. Typically this will be a ``CursorLoader``, but you can implement your own ``Loader`` subclass.创建loader的好时机。
  + ``onLoadFinished()`` — Called when a previously created loader has finished its load.This method is called when a previously created loader has finished its load. This method is guaranteed to be called prior to the release of the last data that was supplied for this loader. At this point you should remove all use of the old data (since it will be released soon), but should not do your own release of the data since its loader owns it and will take care of that.The loader will release the data once it knows the application is no longer using it. For example, if the data is a cursor from a ``CursorLoader``, you should not call ``close()`` on it yourself. If the cursor is being placed in a CursorAdapter, you should use the ``swapCursor()`` method so that the old Cursor is not closed.释放数据。
  + ``onLoaderReset()`` — Called when a previously created loader is being reset, thus making its data unavailable.This method is called when a previously created loader is being reset, thus making its data unavailable. This callback lets you find out when the data is about to be released so you can remove your reference to it.之前创建出来的loader被重置，数据不可用时调用。

####Tasks and Back Stack
+ A task is a collection of activities that users interact with when performing a certain job. The activities are arranged in a stack (the "back stack"), in the order in which each activity is opened.activity活动被放在back stack回退栈中
+ Multiple tasks can be held in the background at once. However, if the user is running many background tasks at the same time, the system might begin destroying background activities in order to recover memory, causing the activity states to be lost.可以同时有多个回退栈
+ Because the activities in the back stack are never rearranged, if your application allows users to start a particular activity from more than one activity, a new instance of that activity is created and pushed onto the stack (rather than bringing any previous instance of the activity to the top). As such, one activity in your application might be instantiated multiple times (even from different tasks). As such, if the user navigates backward using the Back button, each instance of the activity is revealed in the order they were opened (each with their own UI state). However, you can modify this behavior if you do not want an activity to be instantiated more than once.在回退栈中的activity不会被重新组织，如果一个app允许用户从不同的activity激活一个activity，比如，activity A激活Acitivy B，Activity B激活Activity C，Activity C激活Activity B，那么此时的Activity B是重新实例化的。当然也可以改变activity的behavior来避免一个activity被多次实例化。
+ When the system stops one of your activities (such as when a new activity starts or the task moves to the background), the system might destroy that activity completely if it needs to recover system memory. When this happens, information about the activity state is lost. If this happens, the system still knows that the activity has a place in the back stack, but when the activity is brought to the top of the stack the system must recreate it (rather than resume it). In order to avoid losing the user's work, you should proactively retain it by implementing the onSaveInstanceState() callback methods in your activity.在back stack中的activity可能会被系统销毁以回收内存，在navigate back to the activity的时候，系统会重新创建它，应该在``onSaveInstanceState``回调方法中保存activity的状态，以免activity的状态丢失。
+ The way Android manages tasks and the back stack, as described above—by placing all activities started in succession in the same task and in a "last in, first out" stack—works great for most applications and you shouldn't have to worry about how your activities are associated with tasks or how they exist in the back stack. However, you might decide that you want to interrupt the normal behavior. Perhaps you want an activity in your application to begin a new task when it is started (instead of being placed within the current task); or, when you start an activity, you want to bring forward an existing instance of it (instead of creating a new instance on top of the back stack); or, you want your back stack to be cleared of all activities except for the root activity when the user leaves the task.You can do these things and more, with attributes in the <activity> manifest element and with flags in the intent that you pass to startActivity().通常back stack会帮你管理好activity的状态，如果想要做一些特别的操作，就需要在activity的manifest 属性和``startActivity``方法的传递参数上费上心思了。
+ Launch modes allow you to define how a new instance of an activity is associated with the current task. You can define different launch modes in two ways:activity启动时和当前task，当前back stack互动的方式可以有两种方式定义：
  + Using the manifest file. When you declare an activity in your manifest file, you can specify how the activity should associate with tasks when it starts.在activity的manifest文件中定义。
  +	Using Intent flags. When you call ``startActivity()``, you can include a flag in the ``Intent`` that declares how (or whether) the new activity should associate with the current task.使用intent flag.
 As such, if Activity A starts Activity B, Activity B can define in its manifest how it should associate with the current task (if at all) and Activity A can also request how Activity B should associate with current task. If both activities define how Activity B should associate with a task, then Activity A's request (as defined in the intent) is honored over Activity B's request (as defined in its manifest).两种方式都定义的时候，以启动当前activity时传递给他的intent flag为准。The behaviors that you specify for your activity with the launchMode attribute can be overridden by flags included with the intent that start your activity.
 + The affinity indicates which task an activity prefers to belong to. By default, all the activities from the same application have an affinity for each other. So, by default, all activities in the same application prefer to be in the same task. However, you can modify the default affinity for an activity. Activities defined in different applications can share an affinity, or activities defined in the same application can be assigned different task affinities.You can modify the affinity for any given activity with the ``taskAffinity`` attribute of the ``<activity>`` element.可以在activity的``taskAffinity``属性中设定activity的亲属关系。If an .apk file contains more than one "application" from the user's point of view, you probably want to use the taskAffinity attribute to assign different affinities to the activities associated with each "application".
 + If the user leaves a task for a long time, the system clears the task of all activities except the root activity. When the user returns to the task again, only the root activity is restored. The system behaves this way, because, after an extended amount of time, users likely have abandoned what they were doing before and are returning to the task to begin something new.如果用户长时间离开一个任务，系统将会清理这个任务的除了root activity之外的所有activity。当用户返回的时候，只有root activity会被恢复。系统这样做是因为，过了一段时间后，用户很可能会丢弃掉之前做的开始新的。
 + You can set up an activity as the entry point for a task by giving it an intent filter with "android.intent.action.MAIN" as the specified action and "android.intent.category.LAUNCHER" as the specified category.An intent filter of this kind causes an **icon** and **label** for the activity to be displayed in the application launcher, giving users a way to launch the activity and to return to the task that it creates any time after it has been launched.只有在``<activity>``元素``<intent-filter>``中``<action>``属性设置为``android.intent.action.MAIN``且``<cateory>``属性设置为``android.intent.categor.LAUNCHER``，activity才会显示在launcher中。Users must be able to leave a task and then come back to it later using this activity launcher. For this reason, the two launch modes that mark activities as always initiating a task, "singleTask" and ""singleInstance", should be used only when the activity has an ACTION_MAIN and a CATEGORY_LAUNCHER filter. Imagine, for example, what could happen if the filter is missing: An intent launches a "singleTask" activity, initiating a new task, and the user spends some time working in that task. The user then presses the Home button. The task is now sent to the background and is not visible. Now the user has no way to return to the task, because it is not represented in the application launcher.在``<activity>``的``launchMode``属性中设置为``singleTask``或者``singleInstance``时，这个activity必须能够被用户再次点击以恢复之前的状态，也就是说这个activity要显示在launcher上，也就是``<action>``和``<category>``属性必须有所设置。

 ###Services
 + Another application component can start a service and it will continue to run in the background even if the user switches to another application. Additionally, a component can bind to a service to interact with it and even perform interprocess communication (IPC).
 + Services Status
   + Started.A service is "started" when an application component (such as an activity) starts it by calling ``startService()``. Once started, a service can run in the background indefinitely, even if the component that started it is destroyed. Usually, a started service performs a single operation and does not return a result to the caller.服务在后台运行不具有确定性，即使激活这个服务的组件被销毁了，服务也可能仍然在运行。
   + Bound.A service is "bound" when an application component binds to it by calling ``bindService()``. A bound service offers a client-server interface that allows components to interact with the service, send requests, get results, and even do so across processes with interprocess communication (IPC). A bound service runs only as long as another application component is bound to it. Multiple components can bind to the service at once, but when all of them unbind, the service is destroyed.被绑定的service只会在激活它的组件绑定它的时候运行，多个组件可以绑定到组件，当所有的组件解绑后，服务被销毁。
Although this documentation generally discusses these two types of services separately, your service can work both ways—it can be started (to run indefinitely) and also allow binding. It's simply a matter of whether you implement a couple callback methods: ``onStartCommand()`` to allow components to start it and ``onBind()`` to allow binding.服务可以运行在两种情形下，只要实现了特定的方法即可。
+ Regardless of whether your application is started, bound, or both, any application component can use the service (even from a separate application), in the same way that any component can use an activity—by starting it with an Intent. However, you can declare the service as private, in the manifest file, and block access from other applications. 在manifest文件中将服务声明为private的，可以阻断其他应用程序的访问。
+ A service runs in the main thread of its hosting process—the service does not create its own thread and does not run in a separate process (unless you specify otherwise). This means that, if your service is going to do any CPU intensive work or blocking operations (such as MP3 playback or networking), you should create a new thread within the service to do that work. By using a separate thread, you will reduce the risk of Application Not Responding (ANR) errors and the application's main thread can remain dedicated to user interaction with your activities.如果service中需要做阻塞当前进程的操作，如播放音乐或者联网，应该将service放到一个单独的线程中，避免出现ANR问题。
+ Create a subclass of Service or one of Service's subclass,override some callback methods.The most important callback methods you should override are:
  + ``onStartCommand()``The system calls this method when another component, such as an activity, requests that the service be started, by calling startService(). Once this method executes, the service is started and can run in the background indefinitely. If you implement this, it is your responsibility to stop the service when its work is done, by calling stopSelf() or stopService(). (If you only want to provide binding, you don't need to implement this method.)系统中其他组件调用``startService``激活这个服务的时候，系统调用Service的这个方法，当这个方法执行的时候，服务被启动并且会无限期运行下去，当这个服务的工作完成后，你应该负责将这个服务停止，可以调用这个服务的``stopSelf``或者``stopService``方法。
  + ``onCreate``The system calls this method when the service is first created, to perform one-time setup procedures (before it calls either ``onStartCommand()`` or ``onBind()``). If the service is already running, this method is not called.
  +　``onDestroy()``The system calls this method when the service is no longer used and is being destroyed. Your service should implement this to clean up any resources such as threads, registered listeners, receivers, etc. This is the last call the service receives.在这个方法中释放资源，这是Service收到的系统最后一个调用方法。
If a component starts the service by calling ``startService()`` (which results in a call to ``onStartCommand()``), then the service remains running until it stops itself with ``stopSelf()`` or another component stops it by calling ``stopService()``.如果一个Service是被调用``startService``起来的，Service一直运行知道Service自身调用``stopSelf``或者被其他组件调用``stopService``来停止运行。
If a component calls ``bindService()`` to create the service (and onStartCommand() is not called), then the service runs only as long as the component is bound to it. Once the service is unbound from all clients, the system destroys it.如果Service是靠一个组件的``bindService``调用起来的，这个Service运行知道这个组件与它解绑，一旦组件与Service解绑，系统将把Service销毁。
+ Like activities (and other components), you must declare all services in your application's manifest file.Just like an activity, a service can define intent filters that allow other components to invoke the service using implicit intents. By declaring intent filters, components from any application installed on the user's device can potentially start your service if your service declares an intent filter that matches the intent another application passes to startService().If you plan on using your service only locally (other applications do not use it), then you don't need to (and should not) supply any intent filters. Without any intent filters, you must start the service using an intent that explicitly names the service class. More information about starting a service is discussed below.Additionally, you can ensure that your service is private to your application only if you include the android:exported attribute and set it to "false". This is effective even if your service supplies intent filters.可以定义Service的``intent-filter``属性来让其他应用程序来隐式调用服务，如果不想让其他应用程序调用服务，不应该提供intent filters，或者可以将Service的``android:exported``属性设置为false，这样即使设置了intent filters，其他应用也不能调用这个服务了。
+ A services runs in the same process as the application in which it is declared and in the main thread of that application, by default. So, if your service performs intensive or blocking operations while the user interacts with an activity from the same application, the service will slow down activity performance. To avoid impacting application performance, you should start a new thread inside the service.一个Service默认运行在和当前应用的同一个进程中。如果Service中有阻塞操作，应该在Service中单独开一个线程。
+ 创建一个Service可以继承Service或者IntentService类。Service is the base class for all services. When you extend this class, it's important that you create a new thread in which to do all the service's work, because the service uses your application's main thread, by default, which could slow the performance of any activity your application is running.继承Service时应该注意如果有阻塞性操作应该起一个新的线程来处理相关事务。IntentService is a subclass of Service that uses a worker thread to handle all start requests, one at a time. This is the best option if you don't require that your service handle multiple requests simultaneously. All you need to do is implement ``onHandleIntent()``, which receives the intent for each start request so you can do the background work.``IntentService``使用一个worker thread来处理所有请求，如果对并发要求不高可以考虑使用这个。
+ 如果一个Service不用同时处理多个请求，可以考虑继承``IntentService``。继承``IntentService``的时候做了下面的事：
  + Creates a default worker thread that executes all intents delivered to ``onStartCommand()`` separate from your application's main thread.创建一个独立于主线程的工作线程来执行所有发送给``onStartCommand``的intent。
  + Creates a work queue that passes one intent at a time to your ``onHandleIntent()`` implementation, so you never have to worry about multi-threading.创建一个工作队列，一次发送一个Intent给``onHandleIntent``来处理，这样就不用担心多线程的问题了。
  + Stops the service after all start requests have been handled, so you never have to call ``stopSelf()``.当所有的请求被处理完后停止服务，这样就不用调用``stopSelf``了。
  + Provides default implementation of ``onBind()`` that returns null.
  + Provides a default implementation of ``onStartCommand()`` that sends the intent to the work queue and then to your ``onHandleIntent()`` implementation.
All this adds up to the fact that all you need to do is implement onHandleIntent() to do the work provided by the client. (Though, you also need to provide a small constructor for the service.)所有你需要做的只是实现``onHandleIntent``函数，此外还需要提供一个构造函数。Besides onHandleIntent(), the only method from which you don't need to call the super class is onBind() (but you only need to implement that if your service allows binding).除了``onHandleIntent``和``onBind``方法不用调用父类的super方法外，其他均需要，当然只有Service需要绑定到其他组件的时候才需要实现``onBind``。
+ Using ``IntentService`` makes your implementation of a started service very simple. If, however, you require your service to perform multi-threading (instead of processing start requests through a work queue), then you can extend the Service class to handle each intent.如果Service需要多线程处理而不是在工作队列中处理请求，那么需要继承Service来处理每个Intent。
+ Notice that the ``onStartCommand()`` method must return an integer. The integer is a value that describes how the system should continue the service in the event that the system kills it (as discussed above, the default implementation for IntentService handles this for you, though you are able to modify it). The return value from ``onStartCommand()`` must be one of the following constants:``START_NOT_STICKY``,``START_STICKY``,``START_REDELIVER_INTENT``.``onStartCommand``方法必须返回一个整数，这个整数指导系统如何重启服务。
+ The ``startService()`` method returns immediately and the Android system calls the service's ``onStartCommand()`` method. If the service is not already running, the system first calls ``onCreate()``, then calls ``onStartCommand()``.调用``startService``的时候，系统调用服务的``onStartCommand``方法，如果服务没有起来，系统先调用服务的``onCreate``方法，然后调用``onStartCommand``方法。If the service does not also provide binding, the intent delivered with ``startService()`` is the only mode of communication between the application component and the service. However, if you want the service to send a result back, then the client that starts the service can create a PendingIntent for a broadcast (with ``getBroadcast()``) and deliver it to the service in the Intent that starts the service. The service can then use the broadcast to deliver a result.如果需要在startService后，Service返回一个结果，应该进行相关处理。
+ Once requested to stop with ``stopSelf()`` or ``stopService()``, the system destroys the service as soon as possible.调用``stopSelf``和``stopService``后，系统尽快销毁服务。However, if your service handles multiple requests to onStartCommand() concurrently, then you shouldn't stop the service when you're done processing a start request, because you might have since received a new start request (stopping at the end of the first request would terminate the second one). To avoid this problem, you can use stopSelf(int) to ensure that your request to stop the service is always based on the most recent start request. That is, when you call stopSelf(int), you pass the ID of the start request (the startId delivered to onStartCommand()) to which your stop request corresponds. Then if the service received a new start request before you were able to call stopSelf(int), then the ID will not match and the service will not stop.如果Service需要同时处理多个``onStartCommand``请求，应该使用``stopSelf``而不是``stopService``。
+ A bound service is one that allows application components to bind to it by calling ``bindService()`` in order to create a long-standing connection (and generally does not allow components to start it by calling ``startService()``).应该通过``bindService``来启动bound Service，而不是``startService``。You should create a bound service when you want to interact with the service from activities and other components in your application or to expose some of your application's functionality to other applications, through interprocess communication (IPC).在App中的其他组件需要与Service交互的时候或者需要将应用的功能暴漏给其他应用程序的时候，应该创建一个bound service。To create a bound service, you must implement the ``onBind()`` callback method to return an IBinder that defines the interface for communication with the service. Other application components can then call ``bindService()`` to retrieve the interface and begin calling methods on the service. The service lives only to serve the application component that is bound to it, so when there are no components bound to the service, the system destroys it (you do not need to stop a bound service in the way you must when the service is started through ``onStartCommand()``).Bound Service实现``onBind``回调方法返回一个和Service通信的IBinder接口。其他应用组件调用``bindService``来检索接口并且调用Service中的方法。Service在有应用组件绑定到它的时候存活，当没有组件绑定到它的时候就会被系统销毁。如果采用``onStartCommand``方法起的服务，那就必须自己停止服务，而Bound Service不需要。To create a bound service, the first thing you must do is define the interface that specifies how a client can communicate with the service. This interface between the service and a client must be an implementation of ``IBinder`` and is what your service must return from the ``onBind()`` callback method. Once the client receives the ``IBinder``, it can begin interacting with the service through that interface.创建一个Bound Service，第一必须定义一个接口，这个接口表明一个客户端和Service通信的方式。这个接口从Service的``onBind``方法返回并且必须是一个``IBinder``实现。一旦一个client接收到了``IBinder``，它就可以通过这个IBinder接口和Service通信了。
+ Once running, a service can notify the user of events using Toast Notifications or Status Bar Notifications.Service运行的时候可以通过Toast或者Status Bar来通知用户。
+ A foreground service is a service that's considered to be something the user is actively aware of and thus not a candidate for the system to kill when low on memory. A foreground service must provide a notification for the status bar, which is placed under the "Ongoing" heading, which means that the notification cannot be dismissed unless the service is either stopped or removed from the foreground.Foreground Service运行在前台，不应被系统在低内存时考虑杀死。Foreground Service必须提供Status Bar Notification。For example, a music player that plays music from a service should be set to run in the foreground, because the user is explicitly aware of its operation. The notification in the status bar might indicate the current song and allow the user to launch an activity to interact with the music player.音乐播放器。To request that your service run in the foreground, call ``startForeground()``. This method takes two parameters: an integer that uniquely identifies the notification and the Notification for the status bar. 为了让Service运行在前台，应该调用``startForeground``方法。To remove the service from the foreground, call ``stopForeground()``. This method takes a boolean, indicating whether to remove the status bar notification as well. This method does not stop the service. However, if you stop the service while it's still running in the foreground, then the notification is also removed.将一个Foreground Service移出前台，应该调用``stopForeground``，这个方法有个boolean参数来表明是否移出status bar notification，``stopForeground``不会停止进程。
+ Service Lifecycle.The service lifecycle—from when it's created to when it's destroyed—can follow two different paths:
  + A started service.The service is created when another component calls ``startService()``. The service then runs indefinitely and must stop itself by calling ``stopSelf()``. Another component can also stop the service by calling ``stopService()``. When the service is stopped, the system destroys it..
  + A bound service.The service is created when another component (a client) calls ``bindService()``. The client then communicates with the service through an ``IBinder`` interface. The client can close the connection by calling ``unbindService()``. Multiple clients can bind to the same service and when all of them unbind, the system destroys the service. (The service does not need to stop itself.)所有绑定到Service的组件和Service解绑后Service才会被销毁。
####Bound Service
+ A bound service is an implementation of the Service class that allows other applications to bind to it and interact with it. To provide binding for a service, you must implement the ``onBind()`` callback method. This method returns an ``IBinder`` object that defines the programming interface that clients can use to interact with the service.创建一个bound service，必须实现``onBind``回调方法，这个方法返回一个``IBinder``接口，这个接口定义了client和service如何交互。
+ A client can bind to the service by calling ``bindService()``. When it does, it must provide an implementation of ``ServiceConnection``, which monitors the connection with the service. The ``bindService()`` method returns immediately without a value, but when the Android system creates the connection between the client and service, it calls ``onServiceConnected()`` on the ``ServiceConnection``, to deliver the ``IBinder`` that the client can use to communicate with the service.一个client必须实现``ServiceConnection``才能调用``bindService``与service交互，这个``ServiceConnection``监控着client和service的通信，当系统建立client和service的连接时，系统会调用``ServiceConnection``的``onServiceConnected``方法。
+ Multiple clients can connect to the service at once. However, the system calls your service's ``onBind()`` method to retrieve the ``IBinder`` only when the first client binds. The system then delivers the same IBinder to any additional clients that bind, without calling ``onBind()`` again.系统只在第一个client连接service时调用service的``onBind``方法，返回的``IBinder``会被系统传递给其他的client。When the last client unbinds from the service, the system destroys the service (unless the service was also started by startService()).
+ When creating a service that provides binding, you must provide an ``IBinder`` that provides the programming interface that clients can use to interact with the service.创建一个bound service，必须提供一个IBinder来供client和service互动。 There are three ways you can define the interface:
  + ``Extending the Binder class``If your service is private to your own application and runs in the same process as the client (which is common), you should create your interface by extending the Binder class and returning an instance of it from onBind(). The client receives the Binder and can use it to directly access public methods available in either the Binder implementation or even the Service.如果服务只被内部组件调用，和client运行在一个进程中，应该通过继承Binder类来创建IBinder接口。This is the preferred technique when your service is merely a background worker for your own application. The only reason you would not create your interface this way is because your service is used by other applications or across separate processes.如果service需要被其他应用使用或者跨进程，那么不应该这样做。
  + ``Using a Messenger``If you need your interface to work across different processes, you can create an interface for the service with a Messenger. In this manner, the service defines a Handler that responds to different types of Message objects. This Handler is the basis for a Messenger that can then share an IBinder with the client, allowing the client to send commands to the service using Message objects. Additionally, the client can define a Messenger of its own so the service can send messages back.This is the simplest way to perform interprocess communication (IPC), because the Messenger queues all requests into a single thread so that you don't have to design your service to be thread-safe.
  + ``Using AIDL``AIDL (Android Interface Definition Language) performs all the work to decompose objects into primitives that the operating system can understand and marshall them across processes to perform IPC. The previous technique, using a Messenger, is actually based on AIDL as its underlying structure. As mentioned above, the Messenger creates a queue of all the client requests in a single thread, so the service receives requests one at a time. If, however, you want your service to handle multiple requests simultaneously, then you can use AIDL directly. In this case, your service must be capable of multi-threading and be built thread-safe.To use AIDL directly, you must create an .aidl file that defines the programming interface. The Android SDK tools use this file to generate an abstract class that implements the interface and handles IPC, which you can then extend within your service.尽量不要使用AIDL。
+ 继承Binder，If your service is used only by the local application and does not need to work across processes, then you can implement your own Binder class that provides your client direct access to public methods in the service.This works only if the client and service are in the same application and process, which is most common.这只在client和service在同一个应用和进程的情况下有用，这也是最常见的情形。Here's how to set it up:
  + In your service, create an instance of Binder that either:contains public methods that the client can call,returns the current Service instance, which has public methods the client can call,or, returns an instance of another class hosted by the service with public methods the client can call
  + Return this instance of ``Binder`` from the ``onBind()`` callback method.
  + In the client, receive the ``Binder`` from the ``onServiceConnected()`` callback method and make calls to the bound service using the methods provided.
The reason the service and client must be in the same application is so the client can cast the returned object and properly call its APIs. The service and client must also be in the same process, because this technique does not perform any marshalling across processes.Client和Service必须在同一个应用中，且必须在同一个进程中。

###AndroidManifest.xml
+ The core components of an application (its activities, services, and broadcast receivers) are activated by intents. An intent is a bundle of information (an Intent object) describing a desired action — including the data to be acted upon, the category of component that should perform the action, and other pertinent instructions. Android locates an appropriate component to respond to the intent, launches a new instance of the component if one is needed, and passes it the Intent object.一个应用程序的核心组件（Activity，Service，Broadcast Receiver）是被Intent激活的。Intent包含了需要处理的数据，处理这些数据的组件category和其他Intent相关信息。
+ 组件通过intent过滤器表明了自身的能力——能响应的intent的种类。由于android系统在运行之前必须明确组件能够处理哪些intent，因此可以在manifest文件中声明intent过滤器。一个组件可以有多个不同的过滤器，代表不同的能力。